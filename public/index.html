<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>睡前总结</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="睡前总结">
<meta property="og:url" content="https://inceptiongt.github.io/index.html">
<meta property="og:site_name" content="睡前总结">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="睡前总结">
  
    <link rel="alternate" href="/atom.xml" title="睡前总结" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">睡前总结</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://inceptiongt.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-react" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/12/react/" class="article-date">
  <time datetime="2018-11-12T04:06:52.000Z" itemprop="datePublished">2018-11-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/12/react/">react</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><ul>
<li>更新界面的两个办法:1、创建一个新的元素，然后将它传入 ReactDOM.render() 方法; 2、this.setState()<h2 id="组件与Props"><a href="#组件与Props" class="headerlink" title="组件与Props"></a>组件与Props</h2></li>
<li>组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。</li>
<li>所有的React组件必须像纯函数那样使用它们的props。</li>
<li>props与state: state和props之间最重要的区别是props是从父组件传递的，而state是由组件本身管理的。组件不能改变其props，但可以改变state。 通过使用this.setState()。 只有定义为类的组件才可以具有状态。</li>
<li>受控 &amp; 非受控组件</li>
<li><a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">React 理念</a>1、按UI划分出组件层级；2、用React创建一个静态版本；3、确定哪些数据是state；4、确定你的State应该位于哪里。。。。。。</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="避免重复渲染与shouldComponentUpdate应用"><a href="#避免重复渲染与shouldComponentUpdate应用" class="headerlink" title="避免重复渲染与shouldComponentUpdate应用"></a>避免重复渲染与shouldComponentUpdate应用</h3><ul>
<li>React组件更新DOM（调用浏览器DOMapi）决策<br>组件生命周期shouldComponentUpdate(preProps, preState)，默认返回 true，即始终会执行 render() 方法，然后做 Virtual DOM 比较，并得出是否需要做真实 DOM 更新；先看SCU，再看vDOMEq：<br><img src="https://react.docschina.org/static/should-component-update-5ee1bdf4779af06072a17b7a0654f6db-9a3ff.png" alt="渲染"><br>对其中每个组件来说，SCU表明了shouldComponentUpdate的返回内容，vDOMEq表明了待渲染的React元素与原始元素是否相等，最后，圆圈的颜色表明这个组件是否需要重新渲染。（绿色true，红色flase）</li>
<li>当一个组件的props或者state改变时，React通过比较新返回的元素（render()返回）和之前渲染的元素来决定是否有必要更新实际的DOM。当他们不相等时，React会更新DOM。</li>
<li>性能优化思路：如果你知道在某些情况下你的组件不需要更新，你可以在shouldComponentUpdate内返回false来跳过整个渲染进程，该进程包括了对该组件和之后的内容调用render()指令及Virtual DOM比较。</li>
<li>React.PureComponent（没看懂）</li>
</ul>
<h2 id="协调（Reconciliation）"><a href="#协调（Reconciliation）" class="headerlink" title="协调（Reconciliation）"></a>协调（Reconciliation）</h2><ul>
<li>关于Virtual DOM的比较算法，无约束的情况下算法时间复杂度O(n^3)。</li>
<li>约束两点，提高算法效率到O(n)<br>两个不同类型的元素将产生不同的树。<br>通过渲染器附带key属性，开发者可以示意哪些子元素可能是稳定的。（key必须在其兄弟节点中是唯一的，而非全局唯一）</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://inceptiongt.github.io/2018/11/12/react/" data-id="cjogi9d770005wxg5696ekhf0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/10/hello-world/" class="article-date">
  <time datetime="2018-11-10T03:46:53.486Z" itemprop="datePublished">2018-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/10/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://inceptiongt.github.io/2018/11/10/hello-world/" data-id="cjogi9d750004wxg54hpakp5q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-待归档" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/10/待归档/" class="article-date">
  <time datetime="2018-10-10T11:32:03.000Z" itemprop="datePublished">2018-10-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/10/待归档/">待归档</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>我们书写 JSX 的时候一般都会带上换行和缩进，这样可以增强代码的可读性。与此同时，我们同样推荐在 JSX 代码的外面扩上一个小括号，这样可以防止 <a href="http://stackoverflow.com/q/2846283" target="_blank" rel="noopener">分号自动插入</a> 的 bug。</li>
<li>因为 JSX 的特性更接近 JavaScript 而不是 HTML , 所以 React DOM 使用 camelCase 小驼峰命名 来定义属性的名称，而不是使用 HTML 的属性名称。例如，class 变成了 className，而 tabindex 则对应着 tabIndex。</li>
<li>JSX 防注入攻击–React DOM 在渲染之前默认会 <a href="https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html" target="_blank" rel="noopener">过滤</a> 所有传入的值。它可以确保你的应用不会被注入攻击。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS(跨站脚本) 攻击。</li>
<li>JSX会经过babel转译器转换成一个名为 React.createElement() 的方法调用。该方法返回一个对象。</li>
<li>组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。</li>
</ul>
<h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><ul>
<li>更新界面的两个办法:1、创建一个新的元素，然后将它传入 ReactDOM.render() 方法; 2、this.setState()</li>
<li>props与state: state和props之间最重要的区别是props是从父组件传递的，而state是由组件本身管理的。组件不能改变其props，但可以改变state。 通过使用this.setState()。 只有定义为类的组件才可以具有状态。</li>
<li>受控 &amp; 非受控组件</li>
<li><a href="https://react.docschina.org/docs/thinking-in-react.html" target="_blank" rel="noopener">React 理念</a>1、按UI划分出组件层级；2、用React创建一个静态版本；3、确定哪些数据是state；4、确定你的State应该位于哪里。。。。。。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://inceptiongt.github.io/2018/10/10/待归档/" data-id="cjogi9d7c0007wxg5pjg3110t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS运行时及闭包" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/21/JS运行时及闭包/" class="article-date">
  <time datetime="2018-09-21T07:49:44.000Z" itemprop="datePublished">2018-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/21/JS运行时及闭包/">JS运行时及闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一些结论"><a href="#一些结论" class="headerlink" title="一些结论"></a>一些结论</h1><h2 id="执行堆栈，堆的是执行上下文（execution-content）"><a href="#执行堆栈，堆的是执行上下文（execution-content）" class="headerlink" title="执行堆栈，堆的是执行上下文（execution content）"></a>执行堆栈，堆的是执行上下文（execution content）</h2><h2 id="ec-执行上下文-包括：变量对象（VO）、作用域链（ScriptChain）、this指向"><a href="#ec-执行上下文-包括：变量对象（VO）、作用域链（ScriptChain）、this指向" class="headerlink" title="ec(执行上下文)包括：变量对象（VO）、作用域链（ScriptChain）、this指向"></a>ec(执行上下文)包括：变量对象（VO）、作用域链（ScriptChain）、this指向</h2><h2 id="变量对象创建过程：解释了各种变量提升等问题"><a href="#变量对象创建过程：解释了各种变量提升等问题" class="headerlink" title="变量对象创建过程：解释了各种变量提升等问题"></a>变量对象创建过程：解释了各种变量提升等问题</h2><h2 id="作用域链：解释了闭包"><a href="#作用域链：解释了闭包" class="headerlink" title="作用域链：解释了闭包"></a>作用域链：解释了闭包</h2><h2 id="执行堆栈的顺序决定了函数执行顺序，作用域链决定了标识符在哪个范围取值"><a href="#执行堆栈的顺序决定了函数执行顺序，作用域链决定了标识符在哪个范围取值" class="headerlink" title="执行堆栈的顺序决定了函数执行顺序，作用域链决定了标识符在哪个范围取值"></a>执行堆栈的顺序决定了函数执行顺序，作用域链决定了标识符在哪个范围取值</h2><h2 id="通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量。比如在上面的例子中，我们在函数bar的执行环境中访问到了函数foo的a变量。个人认为，从应用层面，这是闭包最重要的特性。利用这个特性，我们可以实现很多有意思的东西。"><a href="#通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量。比如在上面的例子中，我们在函数bar的执行环境中访问到了函数foo的a变量。个人认为，从应用层面，这是闭包最重要的特性。利用这个特性，我们可以实现很多有意思的东西。" class="headerlink" title="通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量。比如在上面的例子中，我们在函数bar的执行环境中访问到了函数foo的a变量。个人认为，从应用层面，这是闭包最重要的特性。利用这个特性，我们可以实现很多有意思的东西。"></a>通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量。比如在上面的例子中，我们在函数bar的执行环境中访问到了函数foo的a变量。个人认为，从应用层面，这是闭包最重要的特性。利用这个特性，我们可以实现很多有意思的东西。</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://inceptiongt.github.io/2018/09/21/JS运行时及闭包/" data-id="cjogi9d700002wxg59tgha7tg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-浏览器原理与性能" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/03/浏览器原理与性能/" class="article-date">
  <time datetime="2018-08-03T02:41:40.000Z" itemprop="datePublished">2018-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/03/浏览器原理与性能/">浏览器原理与性能</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="浏览器组成"><a href="#浏览器组成" class="headerlink" title="浏览器组成"></a>浏览器组成</h1><h2 id="呈现引擎"><a href="#呈现引擎" class="headerlink" title="呈现引擎"></a>呈现引擎</h2><p>负责 HTML、CSS 代码的解析，最终把内容呈现页面上；例如Webkit。</p>
<h2 id="JavaScript-解释器"><a href="#JavaScript-解释器" class="headerlink" title="JavaScript 解释器"></a>JavaScript 解释器</h2><p>用于解析和执行 JavaScript 代码，例如V8。</p>
<h2 id="网络模块"><a href="#网络模块" class="headerlink" title="网络模块"></a>网络模块</h2><p>用于网络调用，比如 HTTP 请求。</p>
<h1 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h1><ol>
<li>解析Html、css、js文件生成DOMtree和CSSStyleRules</li>
<li>合成Render Tree</li>
<li>布局Layout</li>
<li>绘制Paint</li>
</ol>
<p><img src="https://coolshell.cn/wp-content/uploads/2013/05/Render-Process-768x250.jpg" alt="主流程" title="主流程"></p>
<p><img src="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/webkitflow.png" alt="主流程" title="主流程"></p>
<h1 id="解析Parse过程和DOMContentLoaded事件"><a href="#解析Parse过程和DOMContentLoaded事件" class="headerlink" title="解析Parse过程和DOMContentLoaded事件"></a>解析Parse过程和DOMContentLoaded事件</h1><h2 id="主要问题：HTML文档解析、js及css及图片等外部资源加载、js脚本执行、CSS解析-的顺序"><a href="#主要问题：HTML文档解析、js及css及图片等外部资源加载、js脚本执行、CSS解析-的顺序" class="headerlink" title="主要问题：HTML文档解析、js及css及图片等外部资源加载、js脚本执行、CSS解析 的顺序"></a>主要问题：HTML文档解析、js及css及图片等外部资源加载、js脚本执行、CSS解析 的顺序</h2><h2 id="包含内联样式和内联脚本的-HTML-文档"><a href="#包含内联样式和内联脚本的-HTML-文档" class="headerlink" title="包含内联样式和内联脚本的 HTML 文档"></a>包含内联样式和内联脚本的 HTML 文档</h2><p>浏览器解析 HTML，构建 DOM 树<br>当文档解析到\&lt;style>标签时，样式信息开始被解析，CSSSR构建，但是它并不会影响到 HTML 的解析和 DOM 树的构建。<br>当文档解析到\&lt;script>标签时，因为脚本有可能改变 DOM Tree，所以 HTML 的解析必须等到脚本执行完毕后再继续。脚本又有可能操作 CSSSR ，所以脚本必须等到 CSS 解析完毕后才能执行。确保此刻 CSS 解析完成，脚本被交到 JS 引擎手里，由 JS 引擎执行。当脚本执行完毕，HTML 继续解析，直到全部 HTML 解析完毕，DOM 树构建完成（触发 DOMContentLoaded 事件）。  </p>
<h2 id="包含外部-CSS-和脚本的-HTML-文档"><a href="#包含外部-CSS-和脚本的-HTML-文档" class="headerlink" title="包含外部 CSS 和脚本的 HTML 文档"></a>包含外部 CSS 和脚本的 HTML 文档</h2><p>浏览器首先扫描 HTML 文档  </p>
<p>查看有哪些外部资源需要启动 network 模块来请求资源，并在 HTML 解析的同时，发送所有的请求。CSS 资源加载//完毕后，会立即开始解析构建 CSSSR。但同步js脚本加载完毕后，并不能立刻执行。  </p>
<p>当 HTML 解析到\&lt;script>标签，先确认脚本加载完毕了没，如果没，那得等；如果加载好了，还得看 CSS 解析好了没。如果没，那还得等；如果 CSS 解析好了，那就能把脚本交给 JS 引擎去执行了。  </p>
<p>当 JS 执行完毕，HTML 继续解析，DOM 继续构建，直到全部构建完成，DOMContentLoaded 事件被触发。  </p>
<p>如果脚本有async属性，问题就又不一样了。async属性默认该脚本不会影响到 DOM 内容，所以只要脚本下载完成，（相关）CSS 解析完毕，脚本立刻执行，不用等着 HTML 解析到\&lt;script>标签再开始执行。同样，HTML 也不会等着脚本执行完毕再解析。仿佛两者看不到对方，只管做自己的事情就行了。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>DOMContentLoaded 事件只和 HTML 的加载和解析有关，一旦 HTML 解析完成，这个事件就会被触发，不管此时还有没有CSS的解析、图片的下载或者异步脚本的加载和执行。</li>
<li>DOM 树一旦构建完成，就会开始构建 render 树，并不管 CSS 是否解析完毕。如果构建 render 树的时候，CSS 还没有解析完成，那么 render 树会用占位符代替应该有的 CSSSR 节点，当该节点加载解析好后，再重新计算样式。</li>
<li>同步脚本的执行会阻塞 HTML 的解析，从而会影响到 DOMContentLoaded 事件的触发。同时又要注意，CSS 会阻塞 JS 脚本的执行，从而间接影响到 HTML 的解析和 DOMContentLoaded 事件的触发。</li>
</ul>
<h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p>WebKit 都进行了这项优化。在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>\&lt;script>外部加载的js脚本1又引起了外部js加载2，DOMContentLoaded等2执行完再触发</li>
</ul>
<h1 id="window-performance"><a href="#window-performance" class="headerlink" title="window.performance"></a>window.performance</h1><p>window.performance 提供了一组精确的时间戳，经过简单的计算就能得出一些网页性能数据  </p>
<ul>
<li>timing:</li>
</ul>
<pre><code>// 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等
navigationStart: 1441112691935,

// 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0
unloadEventStart: 0,

// 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳
unloadEventEnd: 0,

// 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0 
redirectStart: 0,

// 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0 
redirectEnd: 0,

// 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前
fetchStart: 1441112692155,

// DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
domainLookupStart: 1441112692155,

// DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
domainLookupEnd: 1441112692155,

// HTTP（TCP） 开始建立连接的时间，如果是持久连接，则与 fetchStart 值相等
// 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间
connectStart: 1441112692155,

// HTTP（TCP） 完成建立连接的时间（完成握手），如果是持久连接，则与 fetchStart 值相等
// 注意如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间
// 注意这里握手结束，包括安全连接建立完成、SOCKS 授权通过
connectEnd: 1441112692155,

// HTTPS 连接开始的时间，如果不是安全连接，则值为 0
secureConnectionStart: 0,

// HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存
// 连接错误重连时，这里显示的也是新建立连接的时间
requestStart: 1441112692158,

// HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存
responseStart: 1441112692686,

// HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存
responseEnd: 1441112692687,

// 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading，并将抛出 readystatechange 相关事件
domLoading: 1441112692690,

// 完成解析 DOM 树的时间，Document.readyState 变为 interactive，并将抛出 readystatechange 相关事件
// 注意只是 DOM 树解析完成，这时候并没有开始加载网页内的资源
domInteractive: 1441112693093,

// DOM 解析完成后，网页内资源加载开始的时间
// 在 DOMContentLoaded 事件抛出前发生
domContentLoadedEventStart: 1441112693093,

// DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）
domContentLoadedEventEnd: 1441112693101,

// DOM 树解析完成，且资源也准备就绪的时间，Document.readyState 变为 complete，并将抛出 readystatechange 相关事件
domComplete: 1441112693214,

// load 事件发送给文档，也即 load 回调函数开始执行的时间
// 注意如果没有绑定 load 事件，值为 0
loadEventStart: 1441112693214,

// load 事件的回调函数执行完毕的时间
loadEventEnd: 1441112693215

// 字母顺序
// connectEnd: 1441112692155,
// connectStart: 1441112692155,
// domComplete: 1441112693214,
// domContentLoadedEventEnd: 1441112693101,
// domContentLoadedEventStart: 1441112693093,
// domInteractive: 1441112693093,
// domLoading: 1441112692690,
// domainLookupEnd: 1441112692155,
// domainLookupStart: 1441112692155,
// fetchStart: 1441112692155,
// loadEventEnd: 1441112693215,
// loadEventStart: 1441112693214,
// navigationStart: 1441112691935,
// redirectEnd: 0,
// redirectStart: 0,
// requestStart: 1441112692158,
// responseEnd: 1441112692687,
// responseStart: 1441112692686,
// secureConnectionStart: 0,
// unloadEventEnd: 0,
// unloadEventStart: 0
</code></pre><h1 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h1><h2 id="DOMContentLoaded事件"><a href="#DOMContentLoaded事件" class="headerlink" title="DOMContentLoaded事件"></a>DOMContentLoaded事件</h2><p>在DOM树构建完毕后被触发，我们可以在这个阶段使用js去访问元素。<br>async和defer的脚本可能还没有执行。<br>图片及其他资源文件可能还在下载中。</p>
<h2 id="load事件"><a href="#load事件" class="headerlink" title="load事件"></a>load事件</h2><p>在页面所有资源被加载完毕后触发，通常我们不会用到这个事件，因为我们不需要等那么久。</p>
<h2 id="beforeunload"><a href="#beforeunload" class="headerlink" title="beforeunload"></a>beforeunload</h2><p>在用户即将离开页面时触发，它返回一个字符串，浏览器会向用户展示并询问这个字符串以确定是否离开。</p>
<h2 id="unload"><a href="#unload" class="headerlink" title="unload"></a>unload</h2><p>在用户已经离开时触发，我们在这个阶段仅可以做一些没有延迟的操作，由于种种限制，很少被使用。</p>
<h2 id="document-readyState"><a href="#document-readyState" class="headerlink" title="document.readyState"></a>document.readyState</h2><p>表征页面的加载状态，可以在readystatechange中追踪页面的变化状态：</p>
<ul>
<li>loading — 页面正在加载中。</li>
<li>interactive – 页面解析完毕，时间上和 DOMContentLoaded同时发生，不过顺序在它之前。</li>
<li>complete – 页面上的资源都已加载完毕，时间上和window.onload同时发生，不过顺序在他之前。</li>
</ul>
<blockquote>
<p><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Resources" target="_blank" rel="noopener">浏览器的工作原理：现代网络浏览器幕后揭秘 - HTML5 Rocks</a><br><a href="https://www.jianshu.com/p/b00db2754cdf" target="_blank" rel="noopener">浏览器的工作原理–简书</a><br><a href="https://coolshell.cn/articles/9666.html" target="_blank" rel="noopener">浏览器的渲染原理简介 | | 酷 壳 - CoolShell</a></p>
</blockquote>
<blockquote>
<p><a href="http://www.alloyteam.com/2015/09/explore-performance/" target="_blank" rel="noopener">初探 performance – 监控网页与程序性能</a><br><a href="https://github.com/fi3ework/Blog/issues/3" target="_blank" rel="noopener">[译]页面生命周期：DOMContentLoaded, load, beforeunload, unload解析</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://inceptiongt.github.io/2018/08/03/浏览器原理与性能/" data-id="cjogi9d7v0009wxg5yxa49p10" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-技能修行" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/26/技能修行/" class="article-date">
  <time datetime="2018-07-26T08:16:28.000Z" itemprop="datePublished">2018-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/26/技能修行/">技能修行</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="vim-操作"><a href="#vim-操作" class="headerlink" title="vim 操作"></a>vim 操作</h1><h2 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h2><h3 id="单词移动"><a href="#单词移动" class="headerlink" title="单词移动"></a>单词移动</h3><ul>
<li>w/W  b/B 单词头</li>
<li>e/E  ge  单词尾<h3 id="行移动"><a href="#行移动" class="headerlink" title="行移动"></a>行移动</h3></li>
<li>gg/G 第一/最后一行； 123G 第123行；50% 文件中间一行；</li>
<li>^/0 行首 $ 行尾<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3></li>
<li>fa 行内查找a</li>
<li>/abc 可写正则、上下光标翻看历史 </li>
<li>/abc\> 只匹配abc </li>
<li>* 或 # 搜索光标所在单字(全字匹配，部分匹配用g*)<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3></li>
<li>：%s/a/b/gc a替换b全局需确认<h3 id="光标滚屏"><a href="#光标滚屏" class="headerlink" title="光标滚屏"></a>光标滚屏</h3></li>
<li>zt/zz/zb 光标在顶、中、底部<h3 id="利用跳转表（类似于浏览器history对象，记录跳转位置）"><a href="#利用跳转表（类似于浏览器history对象，记录跳转位置）" class="headerlink" title="利用跳转表（类似于浏览器history对象，记录跳转位置）"></a>利用跳转表（类似于浏览器history对象，记录跳转位置）</h3>“‘’”（两个单引号）和”<code></code>“(两个反引号，在键盘上和”~”共用一个键)<h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3></li>
<li>m{a-zA-Z} mt创建t标记</li>
<li>‘t / `t 定位到t标记</li>
<li><code></code> 标记间跳转<h3 id="折行"><a href="#折行" class="headerlink" title="折行"></a>折行</h3></li>
<li>zo/O 展开</li>
<li>zc/C 收起<br>[/]z zj/k 折行间移动<h3 id="程序中移动"><a href="#程序中移动" class="headerlink" title="程序中移动"></a>程序中移动</h3></li>
<li>% 括号对之间移动</li>
<li>[{ / [[ / [( <h2 id="重复命令"><a href="#重复命令" class="headerlink" title="重复命令"></a>重复命令</h2></li>
<li>.  文本修改重复</li>
<li>;  行内查找重复 , 回退重复</li>
<li>n  全文查找重复 N 回退重复</li>
<li>&amp;  全文替换重复<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><h3 id="三种方式：操作符-动作、可视化模式、操作符-文本对象"><a href="#三种方式：操作符-动作、可视化模式、操作符-文本对象" class="headerlink" title="三种方式：操作符-动作、可视化模式、操作符-文本对象"></a>三种方式：操作符-动作、可视化模式、操作符-文本对象</h3><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3></li>
<li>x 表示 dl (删除当前光标下的字符)</li>
<li>X 表示 dh (删除光标左边的字符)</li>
<li>D 表示 d$ (删除到行尾)</li>
<li>C 表示 c$ (修改到行尾)</li>
<li>s 表示 cl (修改一个字符)</li>
<li>S 表示 cc (修改一整行)<h3 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h3></li>
<li>diw 删除光标上的单词 (不包括空白字符)</li>
<li>daw 删除光标上的单词 (包括空白字符)<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3></li>
<li>I 移到当前行的第一个非空字符并启动插入模式。</li>
<li>A 移动到行尾并启动插入模式。</li>
<li>O 另起一行并启动插入模式。<h2 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h2></li>
<li>u 撤销 Ctrl+r 反撤销</li>
<li>r/R 编辑当前位置/及右侧位置（进入replace模式）</li>
</ul>
<h1 id="前端调试"><a href="#前端调试" class="headerlink" title="前端调试"></a>前端调试</h1><h2 id="打印日志"><a href="#打印日志" class="headerlink" title="打印日志"></a>打印日志</h2><ul>
<li>console.log()<h2 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3></li>
<li>打断点标记、显式debugger都是在源码上操作的。</li>
<li>源码经过编译（babel）、合并（import）、压缩（uglify）发布到B端，B端如何还原源码。</li>
<li>解决：<a href="https://segmentfault.com/a/1190000008315937" target="_blank" rel="noopener">sourceMap闪亮登场</a><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3></li>
</ul>
<ol>
<li>浏览器调试面板source选项卡<br>直接打断点</li>
<li>VScode + Debugger for Chrome插件<br>VScode打断点标记；代码运行在Chrome上，能在断点处停住；<br>优点： 开发环境、方便打断点<br>原理: 通过chrome.exe –remote-debugging-port=9222启动Chrome， 再通过Chrome提供的Chrome DevTools Protocol打通编辑器的调试工具和Chrome的调试工具<h3 id="调试面板功能介绍"><a href="#调试面板功能介绍" class="headerlink" title="调试面板功能介绍"></a>调试面板功能介绍</h3></li>
</ol>
<ul>
<li>变量<blockquote>
<p>Local<br>Closure<br>Global</p>
</blockquote>
</li>
<li>调用堆栈</li>
<li>监视</li>
<li>断点</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://inceptiongt.github.io/2018/07/26/技能修行/" data-id="cjogi9d7e0008wxg5lkxjwuwd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-坑" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/12/坑/" class="article-date">
  <time datetime="2018-07-12T03:28:20.000Z" itemprop="datePublished">2018-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/12/坑/">坑</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h1><ul>
<li>window.location.origin // IE11</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>yarn安装package报错“unable to get local issuer certificate” // 公司网络问题</li>
<li>network报错Provisional headers are shown<br>// 这个警告的意思是说：请求的资源可能会被（扩展／或其他什么机制）屏蔽掉。<br>之所以会出现这个警告，是因为去获取该资源的请求其实并（还）没有真的发生，所以 Header 里显示的是伪信息，直到服务器真的有响应返回，这里的 Header 信息才会被更新为真实的。不过这一切也可能不会发生，因为该请求可能会被屏蔽。比如说 AdBlock 什么的，当然了不全是浏览器扩展，具体情况具体分析了。</li>
<li>对象通过a[key]方式取值时，变量key为字符串，注意字符串头尾是否含有空格。</li>
<li>webpack.config.js &gt; alias设置的别名，在项目的其他js文件中import也能使用。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://inceptiongt.github.io/2018/07/12/坑/" data-id="cjogi9d7a0006wxg5cp2hp6vz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-7月流水账" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/03/7月流水账/" class="article-date">
  <time datetime="2018-07-03T11:08:54.000Z" itemprop="datePublished">2018-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/07/03/7月流水账/">7月流水账</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="7月3号"><a href="#7月3号" class="headerlink" title="7月3号"></a>7月3号</h1><h2 id="前端路由hashHistory与browserHistory"><a href="#前端路由hashHistory与browserHistory" class="headerlink" title="前端路由hashHistory与browserHistory"></a>前端路由hashHistory与browserHistory</h2><h3 id="为什么需要前端路由"><a href="#为什么需要前端路由" class="headerlink" title="为什么需要前端路由"></a>为什么需要前端路由</h3><p>SPA应用后，用户操作页面后，因为URL不变，当前页面状态流失</p>
<h3 id="符合做路由的条件"><a href="#符合做路由的条件" class="headerlink" title="符合做路由的条件"></a>符合做路由的条件</h3><ol>
<li>造成URL的改变，但不会引起页面重新加载；</li>
<li>这种改变可控（可以被捕捉）</li>
</ol>
<h3 id="hashHistory"><a href="#hashHistory" class="headerlink" title="hashHistory"></a>hashHistory</h3><ul>
<li>hash改变，页面不会刷新</li>
<li>onhashchange时间，监听hash变化</li>
</ul>
<hr>
<ul>
<li>由于hash的存在，造成URL里带有#字符</li>
<li>hash部分不会传给后端</li>
</ul>
<h3 id="browserHistory"><a href="#browserHistory" class="headerlink" title="browserHistory"></a>browserHistory</h3><ul>
<li>html5中，对window.history新增了history.pushState/history.replaceState两个API，通过这两个API修改URL，但不会造成刷新页面</li>
<li>调用上述API，增加的浏览记录，通过history.go()匹配中，不会造成页面刷新</li>
</ul>
<hr>
<ul>
<li>缺少监听history改变的事件，需要考虑修改history的各种途径，从行为上而不是在结果上监听事件</li>
</ul>
<h1 id="7月19号"><a href="#7月19号" class="headerlink" title="7月19号"></a>7月19号</h1><h2 id="webpack2及以上为什么不支持IE8？用es5shim能支持IE8？"><a href="#webpack2及以上为什么不支持IE8？用es5shim能支持IE8？" class="headerlink" title="webpack2及以上为什么不支持IE8？用es5shim能支持IE8？"></a>webpack2及以上为什么不支持IE8？用es5shim能支持IE8？</h2><h2 id="IE8ajax的post请求跨域问题，报错”Error-拒绝访问…”"><a href="#IE8ajax的post请求跨域问题，报错”Error-拒绝访问…”" class="headerlink" title="IE8ajax的post请求跨域问题，报错”Error: 拒绝访问…”"></a>IE8ajax的post请求跨域问题，报错”Error: 拒绝访问…”</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://inceptiongt.github.io/2018/07/03/7月流水账/" data-id="cjogi9d730003wxg5zll5ryss" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-6月流水账" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/21/6月流水账/" class="article-date">
  <time datetime="2018-06-21T06:23:47.000Z" itemprop="datePublished">2018-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/21/6月流水账/">6月流水账</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="21号"><a href="#21号" class="headerlink" title="21号"></a>21号</h1><h2 id="上午"><a href="#上午" class="headerlink" title="上午"></a>上午</h2><ul>
<li>搭建hexo博客系统</li>
<li>。。</li>
<li>。。</li>
</ul>
<h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><ul>
<li>第一种部署方案已经实现</li>
<li>。。</li>
<li>。。</li>
<li>。。</li>
</ul>
<h2 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h2><ul>
<li>WiFi探针、电子围栏、RFID培训</li>
<li>。。</li>
</ul>
<h2 id="hexo部署的两种方案"><a href="#hexo部署的两种方案" class="headerlink" title="hexo部署的两种方案"></a>hexo部署的两种方案</h2><blockquote>
<ul>
<li>hexo generate产生静态文件，利用GitHub Page部署静态网站。</li>
<li>涉及gitHub.blog（开发）/gitHub.inceptiongt.github.io（部署）两个代码库。</li>
<li>本地开发完后通过shell完成hexo generate、复制publish文件夹、push到部署代码库</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>hexo generate生成静态文件，利用http-sever提供web服务，在自己服务器上。</li>
<li>涉及gitHub.blog代码库</li>
<li>本地开发后，hexo generate再git提交，GitHub.blog设置webhook，自己服务器通过git拉取代码，public文件夹被web服务</li>
</ul>
</blockquote>
<h2 id="WiFi探针、电子围栏、RFID"><a href="#WiFi探针、电子围栏、RFID" class="headerlink" title="WiFi探针、电子围栏、RFID"></a>WiFi探针、电子围栏、RFID</h2><ol>
<li>取得mac地址、手机识别号、电话卡识别号；微信号、QQ号、微博号。。。</li>
<li>伪基站，取得手机、电话卡识别号。</li>
<li>追踪芯片，两种主动、被动；应用电瓶车防盗等。</li>
</ol>
<h1 id="22号"><a href="#22号" class="headerlink" title="22号"></a>22号</h1><h2 id="上午-1"><a href="#上午-1" class="headerlink" title="上午"></a>上午</h2><ul>
<li>pm2部署http-server服务</li>
<li>。。。</li>
<li>。。。</li>
</ul>
<h2 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h2><ul>
<li>github代码库webhooks配置</li>
<li>web服务器端webhooks搭建</li>
<li>。。。</li>
</ul>
<h2 id="晚上-1"><a href="#晚上-1" class="headerlink" title="晚上"></a>晚上</h2><ul>
<li>溜了</li>
</ul>
<h2 id="Linux环境变量"><a href="#Linux环境变量" class="headerlink" title="Linux环境变量"></a>Linux环境变量</h2><ul>
<li>把相应的可执行文件路径（bin文件夹）告诉系统，方便调用。</li>
<li>echo $PATH查看环境变量；find –name http-server查看该命令的环境路径。</li>
</ul>
<h2 id="pm2启动npm包，pm2-start-npm-–-run-lt-script"><a href="#pm2启动npm包，pm2-start-npm-–-run-lt-script" class="headerlink" title="pm2启动npm包，pm2 start npm – run \&lt;script>"></a>pm2启动npm包，pm2 start npm – run \&lt;script></h2><h1 id="24号"><a href="#24号" class="headerlink" title="24号"></a>24号</h1><ul>
<li>content/type</li>
<li>json与object</li>
<li>git操作</li>
</ul>
<h1 id="25号"><a href="#25号" class="headerlink" title="25号"></a>25号</h1><h2 id="content-type"><a href="#content-type" class="headerlink" title="content/type"></a>content/type</h2><p>application/json与application/x-www-form-urlencoded</p>
<pre><code>var express = require(&apos;express&apos;)

var bodyParser = require(&apos;body-parser&apos;)

var app = express()

// create application/json parser
var jsonParser = bodyParser.json()

// create application/x-www-form-urlencoded parser
var urlencodedParser = bodyParser.urlencoded({ extended: false })
</code></pre><p>req.boy就能取到值了</p>
<h2 id="json（对象）、object字面量表示法、json字符串"><a href="#json（对象）、object字面量表示法、json字符串" class="headerlink" title="json（对象）、object字面量表示法、json字符串"></a>json（对象）、object字面量表示法、json字符串</h2><p>JSON 只允许”property”: value属性名必须用双引号括起来。</p>
<hr>
<ul>
<li>JSON 只允许”property”: value syntax形式的属性定义。属性名必须用双引号括起来。且属性定义不允许使用简便写法。</li>
<li>JSON中，属性的值仅允许字符串，数字，数组，true，false，null或其他（JSON）对象。 </li>
<li>JSON中，不允许将值设置为函数。</li>
<li>Date 等对象，经JSON.parse()处理后，会变成字符串。</li>
<li>JSON.parse() 不会处理计算的属性名，会当做错误抛出。</li>
</ul>
<h1 id="26号"><a href="#26号" class="headerlink" title="26号"></a>26号</h1><h2 id="fms平台1-5版本优化前端开发环境，要求前后分离、热加载等"><a href="#fms平台1-5版本优化前端开发环境，要求前后分离、热加载等" class="headerlink" title="fms平台1.5版本优化前端开发环境，要求前后分离、热加载等"></a>fms平台1.5版本优化前端开发环境，要求前后分离、热加载等</h2><ul>
<li>后端路由多页应用，改前端路由单页应用</li>
<li>jsp主要作用，公用头部、基本div、该页面的js</li>
<li>接口请求地址可以配置</li>
<li>ejs模板地址改到开发环境</li>
<li>开发环境不影响生产环境打包</li>
</ul>
<h1 id="27号"><a href="#27号" class="headerlink" title="27号"></a>27号</h1><h2 id="webpack打包，webpack-dev-server前端服务"><a href="#webpack打包，webpack-dev-server前端服务" class="headerlink" title="webpack打包，webpack.dev.server前端服务"></a>webpack打包，webpack.dev.server前端服务</h2><h2 id="入口index-html包括公用头部、库js、路由逻辑js"><a href="#入口index-html包括公用头部、库js、路由逻辑js" class="headerlink" title="入口index.html包括公用头部、库js、路由逻辑js"></a>入口index.html包括公用头部、库js、路由逻辑js</h2><h2 id="多页改多页，前端路由"><a href="#多页改多页，前端路由" class="headerlink" title="多页改多页，前端路由"></a>多页改多页，前端路由</h2><ul>
<li>router.js 监听哈希变化，绑定handler</li>
<li>handler主要3个逻辑，初始化容器div、加载容器模板、加载页面逻辑js</li>
</ul>
<blockquote>
<p><code>devDom.empty().load(&#39;dev/route/human.html&#39;, function(){
    $.getScript(&#39;bin/app.bundle.blacklistStart.js&#39;)
})</code></p>
</blockquote>
<h2 id="接口地址配置在入口index-html中；ejs模板加载地址，修改了ejs-js；新建了调试用webpack-congfig-js"><a href="#接口地址配置在入口index-html中；ejs模板加载地址，修改了ejs-js；新建了调试用webpack-congfig-js" class="headerlink" title="接口地址配置在入口index.html中；ejs模板加载地址，修改了ejs.js；新建了调试用webpack.congfig.js"></a>接口地址配置在入口index.html中；ejs模板加载地址，修改了ejs.js；新建了调试用webpack.congfig.js</h2><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>配置没有全部抽出了到一个config.js 文件</li>
<li>修改页面业务js会自动重启、修改页面ejs不会</li>
</ul>
<h1 id="28号"><a href="#28号" class="headerlink" title="28号"></a>28号</h1><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack.dev.server"></a>webpack.dev.server</h2><ul>
<li>安装webpack.config打包文件，保持在内存中，不输出；可以通过host://ip/webpack-dev-server查看</li>
<li><p>自动重启服务方便调试：调试页面js是server自动重启，调试ejs、css不会</p>
<p>因为js经过webpack打包，能追踪；ejs/css是直接当静态文件使用，硬刷新能看效果；</p>
<h2 id="接口地址配置抽出到webpack-config，利用了html-webpack-plugin的template差值"><a href="#接口地址配置抽出到webpack-config，利用了html-webpack-plugin的template差值" class="headerlink" title="接口地址配置抽出到webpack.config，利用了html-webpack-plugin的template差值"></a>接口地址配置抽出到webpack.config，利用了html-webpack-plugin的template差值</h2></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://inceptiongt.github.io/2018/06/21/6月流水账/" data-id="cjogi9d6n0000wxg5ps0j1xod" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-b" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/21/b/" class="article-date">
  <time datetime="2018-06-21T03:08:20.000Z" itemprop="datePublished">2018-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/21/b/">b</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://inceptiongt.github.io/2018/06/21/b/" data-id="cjogi9d6w0001wxg5d5go13yi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/11/12/react/">react</a>
          </li>
        
          <li>
            <a href="/2018/11/10/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/10/10/待归档/">待归档</a>
          </li>
        
          <li>
            <a href="/2018/09/21/JS运行时及闭包/">JS运行时及闭包</a>
          </li>
        
          <li>
            <a href="/2018/08/03/浏览器原理与性能/">浏览器原理与性能</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 GT<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>